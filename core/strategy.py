#!/usr/bin/env python3
"""
DECLARATIVE STRATEGY FRAMEWORK — Strategy base class with regime-aware routing.

Each Strategy implementation generates signals from data using its own logic.
The StrategyRouter in regime_engine selects which strategy to use based on
the current market regime. Strategy parameters are stored as JSONB in the
Supabase `strategy_configs` table for no-code tuning via the dashboard.

Strategies:
- MomentumStrategy: Trend-following with MA crossovers and ADX confirmation
- MeanReversionStrategy: Bollinger bounce + RSI extremes
- BreakoutStrategy: Range expansion with volume confirmation
"""

import logging
import numpy as np
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any

logger = logging.getLogger(__name__)


@dataclass
class StrategySignal:
    """A signal generated by a strategy."""
    symbol: str
    direction: str          # "long", "short", "flat"
    strength: float         # 0-1 conviction
    score: int              # -100 to +100
    strategy_name: str
    reasons: List[str] = field(default_factory=list)
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyConfig:
    """Configuration for a strategy, loaded from DB or defaults."""
    name: str
    enabled: bool = True
    parameters: Dict[str, Any] = field(default_factory=dict)

    def get(self, key: str, default: Any = None) -> Any:
        return self.parameters.get(key, default)


class Strategy(ABC):
    """Base class for all trading strategies."""

    name: str = "base"

    def __init__(self, config: Optional[StrategyConfig] = None):
        self.config = config or StrategyConfig(name=self.name)

    @abstractmethod
    def generate_signals(
        self,
        symbol: str,
        prices: List[float],
        highs: Optional[List[float]] = None,
        lows: Optional[List[float]] = None,
        volumes: Optional[List[float]] = None,
        indicators: Optional[Any] = None,
    ) -> StrategySignal:
        """Generate a trading signal for the given symbol and data."""
        ...

    def _sma(self, data: np.ndarray, period: int) -> float:
        if len(data) < period:
            return float(np.mean(data))
        return float(np.mean(data[-period:]))

    def _rsi(self, prices: np.ndarray, period: int = 14) -> float:
        if len(prices) < period + 1:
            return 50.0
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        avg_gain = float(np.mean(gains[-period:]))
        avg_loss = float(np.mean(losses[-period:]))
        if avg_loss == 0:
            return 100.0
        rs = avg_gain / avg_loss
        return float(100 - (100 / (1 + rs)))


class MomentumStrategy(Strategy):
    """
    Trend-following momentum strategy.
    Enters when short MA crosses above long MA with ADX confirmation.
    """

    name = "momentum"

    def generate_signals(
        self,
        symbol: str,
        prices: List[float],
        highs: Optional[List[float]] = None,
        lows: Optional[List[float]] = None,
        volumes: Optional[List[float]] = None,
        indicators: Optional[Any] = None,
    ) -> StrategySignal:
        arr = np.array(prices, dtype=float)
        if len(arr) < 50:
            return StrategySignal(symbol=symbol, direction="flat", strength=0, score=0,
                                  strategy_name=self.name, reasons=["Insufficient data"])

        current_price = float(arr[-1])
        fast_period = self.config.get("fast_ma", 10)
        slow_period = self.config.get("slow_ma", 30)
        stop_pct = self.config.get("stop_loss_pct", 0.05)
        target_pct = self.config.get("take_profit_pct", 0.12)

        fast_ma = self._sma(arr, fast_period)
        slow_ma = self._sma(arr, slow_period)
        prev_fast = self._sma(arr[:-1], fast_period)
        prev_slow = self._sma(arr[:-1], slow_period)

        rsi = self._rsi(arr)
        score = 0
        reasons = []

        # MA crossover
        if fast_ma > slow_ma and prev_fast <= prev_slow:
            score += 40
            reasons.append(f"Bullish MA crossover ({fast_period}/{slow_period})")
        elif fast_ma > slow_ma:
            score += 20
            reasons.append(f"Fast MA above slow MA")
        elif fast_ma < slow_ma and prev_fast >= prev_slow:
            score -= 40
            reasons.append(f"Bearish MA crossover")
        elif fast_ma < slow_ma:
            score -= 20
            reasons.append(f"Fast MA below slow MA")

        # Momentum confirmation (RSI trending direction)
        if rsi > 55:
            score += 15
            reasons.append(f"RSI bullish ({rsi:.0f})")
        elif rsi < 45:
            score -= 15
            reasons.append(f"RSI bearish ({rsi:.0f})")

        # ADX from indicators if available
        adx = getattr(indicators, "adx", 0) if indicators else 0
        if adx > 25:
            score_boost = 15 if score > 0 else -15
            score += score_boost
            reasons.append(f"ADX confirms trend ({adx:.0f})")

        # Returns momentum
        if len(arr) >= 21:
            ret_20d = (arr[-1] - arr[-21]) / arr[-21] * 100
            if ret_20d > 5:
                score += 10
                reasons.append(f"Strong 20d momentum ({ret_20d:+.1f}%)")
            elif ret_20d < -5:
                score -= 10
                reasons.append(f"Weak 20d momentum ({ret_20d:+.1f}%)")

        score = max(-100, min(100, score))

        if score >= 25:
            direction = "long"
            strength = min(1.0, abs(score) / 80)
            stop_loss = round(current_price * (1 - stop_pct), 2)
            take_profit = round(current_price * (1 + target_pct), 2)
        elif score <= -25:
            direction = "short"
            strength = min(1.0, abs(score) / 80)
            stop_loss = round(current_price * (1 + stop_pct), 2)
            take_profit = round(current_price * (1 - target_pct), 2)
        else:
            direction = "flat"
            strength = 0
            stop_loss = 0
            take_profit = 0

        return StrategySignal(
            symbol=symbol,
            direction=direction,
            strength=round(strength, 3),
            score=score,
            strategy_name=self.name,
            reasons=reasons,
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
        )


class MeanReversionStrategy(Strategy):
    """
    Mean reversion strategy.
    Enters when price is at Bollinger extremes with RSI confirmation.
    """

    name = "mean_reversion"

    def generate_signals(
        self,
        symbol: str,
        prices: List[float],
        highs: Optional[List[float]] = None,
        lows: Optional[List[float]] = None,
        volumes: Optional[List[float]] = None,
        indicators: Optional[Any] = None,
    ) -> StrategySignal:
        arr = np.array(prices, dtype=float)
        if len(arr) < 20:
            return StrategySignal(symbol=symbol, direction="flat", strength=0, score=0,
                                  strategy_name=self.name, reasons=["Insufficient data"])

        current_price = float(arr[-1])
        bb_period = self.config.get("bb_period", 20)
        bb_std = self.config.get("bb_std", 2.0)
        stop_pct = self.config.get("stop_loss_pct", 0.04)
        target_pct = self.config.get("take_profit_pct", 0.06)

        sma = self._sma(arr, bb_period)
        std = float(np.std(arr[-bb_period:])) if len(arr) >= bb_period else float(np.std(arr))
        upper = sma + bb_std * std
        lower = sma - bb_std * std

        bb_pos = (current_price - lower) / (upper - lower) if upper != lower else 0.5
        rsi = self._rsi(arr)

        score = 0
        reasons = []

        # Bollinger Band position
        if bb_pos <= 0.05:
            score += 40
            reasons.append(f"Price at lower Bollinger Band (pos={bb_pos:.2f})")
        elif bb_pos <= 0.15:
            score += 25
            reasons.append(f"Price near lower BB ({bb_pos:.2f})")
        elif bb_pos >= 0.95:
            score -= 40
            reasons.append(f"Price at upper Bollinger Band (pos={bb_pos:.2f})")
        elif bb_pos >= 0.85:
            score -= 25
            reasons.append(f"Price near upper BB ({bb_pos:.2f})")

        # RSI extremes confirm
        if rsi < 25:
            score += 25
            reasons.append(f"RSI oversold ({rsi:.0f})")
        elif rsi < 35:
            score += 10
            reasons.append(f"RSI low ({rsi:.0f})")
        elif rsi > 75:
            score -= 25
            reasons.append(f"RSI overbought ({rsi:.0f})")
        elif rsi > 65:
            score -= 10
            reasons.append(f"RSI high ({rsi:.0f})")

        # Z-score confirmation
        if std > 0:
            zscore = (current_price - sma) / std
            if zscore < -2:
                score += 15
                reasons.append(f"Z-score extreme low ({zscore:.1f})")
            elif zscore > 2:
                score -= 15
                reasons.append(f"Z-score extreme high ({zscore:.1f})")

        score = max(-100, min(100, score))

        if score >= 25:
            direction = "long"
            strength = min(1.0, abs(score) / 70)
            stop_loss = round(current_price * (1 - stop_pct), 2)
            take_profit = round(sma, 2)  # Target mean
        elif score <= -25:
            direction = "short"
            strength = min(1.0, abs(score) / 70)
            stop_loss = round(current_price * (1 + stop_pct), 2)
            take_profit = round(sma, 2)
        else:
            direction = "flat"
            strength = 0
            stop_loss = 0
            take_profit = 0

        return StrategySignal(
            symbol=symbol,
            direction=direction,
            strength=round(strength, 3),
            score=score,
            strategy_name=self.name,
            reasons=reasons,
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
        )


class BreakoutStrategy(Strategy):
    """
    Breakout strategy.
    Enters when price breaks out of recent range with volume confirmation.
    """

    name = "breakout"

    def generate_signals(
        self,
        symbol: str,
        prices: List[float],
        highs: Optional[List[float]] = None,
        lows: Optional[List[float]] = None,
        volumes: Optional[List[float]] = None,
        indicators: Optional[Any] = None,
    ) -> StrategySignal:
        arr = np.array(prices, dtype=float)
        if len(arr) < 30:
            return StrategySignal(symbol=symbol, direction="flat", strength=0, score=0,
                                  strategy_name=self.name, reasons=["Insufficient data"])

        current_price = float(arr[-1])
        lookback = self.config.get("lookback", 20)
        stop_pct = self.config.get("stop_loss_pct", 0.04)
        target_pct = self.config.get("take_profit_pct", 0.10)

        # Range boundaries (excluding last bar)
        range_high = float(np.max(arr[-lookback - 1:-1]))
        range_low = float(np.min(arr[-lookback - 1:-1]))
        range_width = range_high - range_low

        score = 0
        reasons = []

        # Breakout detection
        if current_price > range_high:
            pct_above = (current_price - range_high) / range_high * 100
            score += 35
            reasons.append(f"Breakout above {lookback}-bar high ({pct_above:+.2f}%)")

            # Strong breakout
            if pct_above > 2:
                score += 15
                reasons.append("Strong breakout (>2%)")
        elif current_price < range_low:
            pct_below = (current_price - range_low) / range_low * 100
            score -= 35
            reasons.append(f"Breakdown below {lookback}-bar low ({pct_below:+.2f}%)")

            if abs(pct_below) > 2:
                score -= 15
                reasons.append("Strong breakdown (>2%)")

        # Volume confirmation
        if volumes and len(volumes) >= lookback:
            vol_arr = np.array(volumes, dtype=float)
            avg_vol = float(np.mean(vol_arr[-lookback:-1]))
            current_vol = float(vol_arr[-1])
            if avg_vol > 0:
                vol_ratio = current_vol / avg_vol
                if vol_ratio > 1.5 and abs(score) > 0:
                    vol_boost = 20 if score > 0 else -20
                    score += vol_boost
                    reasons.append(f"Volume confirms ({vol_ratio:.1f}x average)")
                elif vol_ratio < 0.7 and abs(score) > 0:
                    # Low volume breakout is suspect
                    score = int(score * 0.5)
                    reasons.append(f"Low volume breakout ({vol_ratio:.1f}x average)")

        # Range tightness (Bollinger squeeze)
        if range_width > 0 and current_price > 0:
            range_pct = range_width / current_price * 100
            if range_pct < 3:
                score_boost = 10 if score > 0 else -10
                score += score_boost
                reasons.append(f"Tight range ({range_pct:.1f}%) — squeeze breakout")

        score = max(-100, min(100, score))

        if score >= 25:
            direction = "long"
            strength = min(1.0, abs(score) / 70)
            stop_loss = round(range_low, 2)  # Stop below range
            take_profit = round(current_price * (1 + target_pct), 2)
        elif score <= -25:
            direction = "short"
            strength = min(1.0, abs(score) / 70)
            stop_loss = round(range_high, 2)  # Stop above range
            take_profit = round(current_price * (1 - target_pct), 2)
        else:
            direction = "flat"
            strength = 0
            stop_loss = 0
            take_profit = 0

        return StrategySignal(
            symbol=symbol,
            direction=direction,
            strength=round(strength, 3),
            score=score,
            strategy_name=self.name,
            reasons=reasons,
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
        )


# Strategy registry
STRATEGIES = {
    "momentum": MomentumStrategy,
    "mean_reversion": MeanReversionStrategy,
    "breakout": BreakoutStrategy,
}


def get_strategy(name: str, config: Optional[StrategyConfig] = None) -> Strategy:
    """Get a strategy instance by name."""
    cls = STRATEGIES.get(name)
    if cls is None:
        logger.warning(f"Unknown strategy '{name}', falling back to momentum")
        cls = MomentumStrategy
    return cls(config=config)


def get_strategy_for_regime(regime_str: str, config: Optional[StrategyConfig] = None) -> Strategy:
    """Get the recommended strategy for a market regime."""
    regime_strategy_map = {
        "trending_up": "momentum",
        "trending_down": "momentum",
        "ranging": "mean_reversion",
        "high_vol": "mean_reversion",
        "crisis": "mean_reversion",
    }
    name = regime_strategy_map.get(regime_str.lower(), "momentum")
    return get_strategy(name, config)
